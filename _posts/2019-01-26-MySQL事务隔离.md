## 事务的介绍

事务就是一组原子性的sql查询，或者说是一个独立的工作单元。简而言之，事务内的语句要么全部执行成功，要么全部执行失败。

在Mysql中，事务支持是在引擎层实现的，但并不是所有的Mysql引擎都支持事务，比如MyISAM引擎就不支持事务，这也是MyISAM被InnoDB取代的重要原因之一。

提到事务，我们肯定会想到ACID：

- 原子性(Atomicity)
- 一致性(Consistency)
- 隔离性(Isolation)
- 持久性(Durability)

## 隔离级别

当数据库中有多个事务同时执行时，就可能会出现脏读、不可重复读、幻读等问题，因为就有了事务隔离级别的概念。

SQL标准正定义了四种隔离级别：

1. READ UNCOMMITTED (未提交读)

   事务中的修改，即使还没有提交，对其他事务都是可见的。事务可以读取未提交的数据，也被称为脏读(Dirty Read)。

2. READ COMMITTED(提交读)

   一个事务提交后，所做的变更才能被其他事务看到。这个级别也叫不可重复读，因为事务中执行2次相同的查询，可能得到的结果是不一样的。

3. REPEATABLE READ(可重复读)

   一个事务执行的过程中，总是和这个事务在启动时看到的数据是一致的。当然在这个级别下，未提交的数据变更对其他事务也是不可见的。

4. SERIALIZABLE(可串行化)

   对同一行记录，写和读都会加锁，当出现读写锁冲突时，后访问的事务必须等前一个事务执行完成才能继续执行，就会导致大量的超时和锁争用的问题。

在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑为准。

在可重复读这个隔离级别下，这个视图是事务开启的时候创建的，整个事务期间都用这个视图。

在读提交的隔离级别下，这个视图是在sql语句开始执行的时候创建的。

在读未提交的隔离级别下，直接返回记录上的最新值，没有视图概念。

在串行化的隔离级别下，直接用加锁的方式避免并行访问。

配置的方式是将启动参数`transaction-isolation`设置成想要的隔离级别。

查看当前设置：

```mysql
mysql> show variables like 'transaction_isolation';
+-----------------------+-----------------+
| Variable_name         | Value           |
+-----------------------+-----------------+
| transaction_isolation | REPEATABLE-READ |
+-----------------------+-----------------+
1 row in set (0.00 sec)

```

**总之，存在即合理，不同的隔离级别适用于不同的场景，具体我们应该根据业务场景来决定。**

## 事务隔离的实现

在Mysql中，实际上每条记录的更新同时也会记录一条回滚操作，记录上的最新值通过回滚操作，都可以得到前一个状态的值。

系统会自动判断，当没有事务再需要回滚日志时，会删除回滚日志。

为什么不建议使用长事务：

长事务意味着系统里面会存在很老的事务视图，由于这些事务随时可以访问数据库里面的任何数据，所以这个事务提交之前，数据库里可能用到的回滚记录必须保留着，这就会占用大量的存储空间。同时长事务还占用锁资源，也可能拖垮整个库。

## 事务启动的方式

- 显式启动事务语句，begin或者start transaction,提交就是commit,回滚用rollback。
- set autocommit = 0,这个命令会将线程的自动提交关掉，意味着如果执行一个select 语句，这个事务就启动了，并且不会自动提交，直到你主动执行commit或者rollback，或者断开连接。

个人建议还是通过第一种方式显式启动事务，避免长事务的发生。

在 set autocommit = 1 的情况下，用 begin 显式启动的事务，如果执行 commit 则提交事务。如果执行 commit work and chain，则是提交事务并自动启动下一个事务，这样也省去了再次执行 begin 语句的开销。

查询长事务：

下面语句是查询持续时间超过60s的事务

```mysql
mysql> select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))>60;
Empty set (0.00 sec)
```

总结下来，我们在开发过程中，尽量少用长事务，如果无法避免，保证逻辑日志空间足够大，并且支持动态日志空间增长。监控Innodb_trx表，发现长事务报警。



## 参考资料

《高性能Mysql》

极客时间-Mysql实战45讲