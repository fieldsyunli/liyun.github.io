---
layout: post
title: TCP协议学习总结（一）
tags: 网络协议
categories: 网络协议
---

## 前言

本文是学习极客时间《趣谈网络协议》第12节课程时整理的笔记。

## TCP包头格式

![image-20200412195617016](/Users/yunli/Library/Application Support/typora-user-images/image-20200412195617016.png)

源端口号和目标端口号是必不可少，否则数据不知道该分发给哪个应用。

包的序号是为了解决乱序的问题。

确认序号，是为了解决不丢包的问题。发出去的包都应该要有确认，否则不清楚对方有没有收到；没有收到则会重新发送。

状态位：SYN 是发起一个连接，ACK是回复，RST 是重新连接，FIN 是结束连接。TCP是面向连接的，因而双方需要维护连接的状态，这些带状态位的包的发送，会引起双方状态的变更。

通过对TCP头的解析，我们知道要掌握TCP协议，需要重点关注以下几个问题：

- 顺序问题，稳重不乱
- 丢包问题，承诺靠谱
- 连接维护，有始有终
- 流量控制，把握分寸
- 拥塞控制，知进知退



## TCP的三次握手

简单点来说，如下：

> A:您好，我是 A。
> B:您好 A，我是 B。
> A:您好 B。 

我们通常称为“请求 -> 应答 -> 应答之应答” 三个回合。

![image-20200412192954625](/Users/yunli/Library/Application Support/typora-user-images/image-20200412192954625.png)

期初，客户端和服务端都处于CLOSED状态。先是服务端主动监听某个端口，处于LISTEN状态。然后客户端主动发起SYN，之后处于SYN-SENT状态。服务端收到发起的连接，返回SYN,并且AKC客户端的SYN,之后处于SYN-RCVD状态。客户端收到服务端的SYN和ACK之后，发送ACK的ACK,之后处于ESTABLISHED状态，因为一发一收成功了。服务端收到ACK的ACK之后，处于ESTABLISHED状态，因为他也一发一收成功了。



## TCP四次挥手

简而言之，如下：

> A:B 啊，我不想玩了。 
>
> B:哦，你不想玩了啊，我知道了。 
>
> 这个时候，还只是 A 不想玩了，也即 A 不会再发送数据，但是 B 能不能在 ACK 的时候，直接关闭呢? 当然不可以了，很有可能 A 是发完了最后的数据就准备不玩了，但是 B 还没做完自己的事情，还是可以 发送数据的，所以称为半关闭的状态。 
>
> 这个时候 A 可以选择不再接收数据了，也可以选择最后再接收一段数据，等待 B 也主动关闭。 B:A 啊，好吧，我也不玩了，拜拜。
> A:好的，拜拜。 

![image-20200412193527595](/Users/yunli/Library/Application Support/typora-user-images/image-20200412193527595.png)

断开的时候，我们可以看到，当 A 说“不玩了” ，就进入FIN_WAIT_1的状态，B收到消息后，发送知道了，处于CLOSED_WAIT的状态。

A收到B发的知道了，就进入的FIN_WAIT_2的状态，如果这个时候B直接跑路了，那么A则永远停留在这个状态；TCP协议里面并没有对这个状态的处理，但是Linux有，可以调整tcp_fin_timeout这个参数，设置一个超时时间。

如果B发送了 “B也不玩了”的请求到达A时，A发送“知道了”的ACK之后，从FIN_WAIT_2状态结束，考虑到这个ACK B可能收不到，B可能会重新发一次“B也不玩了”；因此TCP协议要求A等待一段时间TIME_WAIT, 这个时间要足够长，长到如果 B 没收到 ACK 的话，“B 说不玩了”会重发 的，A 会重新发一个 ACK 并且足够时间到达 B。 

A 直接跑路还有一个问题是，A 的端口就直接空出来了，但是 B 不知道，B 原来发过的很多包很可能还 在路上，如果 A 的端口被一个新的应用占用了，这个新的应用会收到上个连接中 B 发过来的包，虽然序 列号是重新生成的，但是这里要上一个双保险，防止产生混乱，因而也需要等足够长的时间，等到原来 B 发送的所有的包都死翘翘，再空出端口来。 

等待的时间设为 2MSL，MSL是Maximum Segment Lifetime，报文最大生存时间，它是任何报文在网 络上存在的最长时间，超过这个时间报文将被丢弃。因为 TCP 报文基于是 IP 协议的，而 IP 头中有一个 TTL 域，是 IP 数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减 1，当此值为 0 则数 据报将被丢弃，同时发送 ICMP 报文通知源主机。协议规定 MSL 为 2 分钟，实际应用中常用的是 30 秒，1 分钟和 2 分钟等。 

还有一个异常情况就是，B 超过了 2MSL 的时间，依然没有收到它发的 FIN 的 ACK，怎么办呢?按照 TCP 的原理，B 当然还会重发 FIN，这个时候 A 再收到这个包之后，A 就表示，我已经在这里等了这么 长时间了，已经仁至义尽了，之后的我就都不认了，于是就直接发送 RST，B 就知道 A 早就跑了 。



## TCP状态机

![image-20200412195239066](/Users/yunli/Library/Application Support/typora-user-images/image-20200412195239066.png)

在这个图中，加黑加粗的部分，是上面说到的主要流程，其中阿拉伯数字的序号，是连接过程中的顺 序，而大写中文数字的序号，是连接断开过程中的顺序。加粗的实线是客户端 A 的状态变迁，加粗的虚 线是服务端 B 的状态变迁。 结合状态图学习，更容易理解。

## 参考资料

极客时间《趣谈网络协议》第12节